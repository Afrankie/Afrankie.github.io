<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.83.1"><title>一问搞懂Python进程、线程、协程选择 | Afrankie</title><meta name=description content="A simple and concise hugo theme."><link rel=stylesheet href=https://afrankie.github.io/css/simpleness.css><link rel=canonical href=https://afrankie.github.io/posts/%E4%B8%80%E9%97%AE%E6%90%9E%E6%87%82python%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E9%80%89%E6%8B%A9/><link rel=alternate type=application/rss+xml href title=Afrankie><link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css rel=stylesheet></head><body class=container><nav class=navigation><div class=nav-left><div class="nav-item nav-title"><a href=https://afrankie.github.io/>Afrankie</a></div><div class="nav-item nav-menu"><a href=/>Home</a>
<a href=/about/>About</a></div></div><div class="nav-item nav-right fontawesome"><a href=https://github.com/Afrankie target=_blank><i title=GitHub class="fab fa-github"></i></a>
<a href=https://afrankie.github.io/index.xml target=_blank><i title=RSS class="fas fa-rss"></i></a></div></nav><article class=post><header class=post-header><h1 style=text-align:center>一问搞懂Python进程、线程、协程选择</h1><div class=post-metadata><time datetime=2022-02-23T11:21:00+08:00>February 23, 2022</time> &nbsp;
<i class="far fa-clock"></i>
4 min
58 s
&nbsp;</div></header><div class=post-text><h2 id=tldr>TL;DR</h2><pre><code>if io_bound:
  if io_very_slow:
    print(&quot;use asyncio&quot;)
  else:
    print(&quot;use multithread&quot;)
else:
  print(&quot;use multiprocess&quot;)

</code></pre><h2 id=几个有趣的问题>几个有趣的问题</h2><h3 id=linux中线程和进程的区别>linux中线程和进程的区别？</h3><p>对于linux来说，实际上没有区别，一组线程(>=1)就是一个进程，<a href=https://stackoverflow.com/questions/4894609/will-a-cpu-process-have-at-least-one-thread>参考链接</a>
而在python中，进程和线程最大区别之一就是，多进程不受GIL的影响，而一个进程中的多个线程的运行(一个进程中的多个线程能在不同的cpu上运行)则受GIL的影响，所以多进程（使用合理的进程数量）理论上是最快的。
<a href=https://docs.python.org/3.7/glossary.html#term-global-interpreter-lock>官方GIL解释</a>:assure that only one thread executes Python bytecode at a time.</p><hr><p>先从简单的情况说起，当前讨论范围是单核CPU，某一时刻只能运行一个线程。</p><hr><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>blocking_io</span>():
    <span style=color:#75715e># File operations (such as logging) can block the</span>
    <span style=color:#75715e># event loop: run them in a thread pool.</span>
    <span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;/dev/urandom&#39;</span>, <span style=color:#e6db74>&#39;rb&#39;</span>) <span style=color:#66d9ef>as</span> f:
        <span style=color:#66d9ef>return</span> f<span style=color:#f92672>.</span>read(<span style=color:#ae81ff>100</span>)

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>cpu_bound</span>():
    <span style=color:#75715e># CPU-bound operations will block the event loop:</span>
    <span style=color:#75715e># in general it is preferable to run them in a</span>
    <span style=color:#75715e># process pool.</span>
    <span style=color:#66d9ef>return</span> sum(i <span style=color:#f92672>*</span> i <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span> <span style=color:#f92672>**</span> <span style=color:#ae81ff>7</span>))
</code></pre></div><h3 id=什么时候需要多线程>什么时候需要多线程？</h3><p>多线程适合I/O密集型的任务，例如需要执行n次<code>blocking_io</code>，假设执行方法所需时间为t，只有一个进程的话，就是串行执行，运行时间为n*t。
而对于多线程的情况，虽然同一时间只能有一个线程在执行，在第一个线程在待等待io时候，可以切换到第二个线程执行，当第二个线程在等待io的时候，&mldr;诸如此类。总的运行时间只有t+线程切换的时间(相对较小)。</p><p>举个例子:
I/O密集型（等待的时间占比较大）的任务可以类比为点外卖，假设这个过程分为三部分(下单+外卖员配送+取外卖)，单进程就是你下单取到第一个外卖之后再下单第二个外卖。如果是多线程的话就是，你下单完第一个外卖之后就下单第二个外卖。</p><p>而对于CPU密集型的任务，例如需要执行n次<code>cpu_bound</code>，多线程并不适合，因为没有空闲的时间可以利用，切换进程只会增加总的运行时间。这时候需要多核cpu，同一时间能够运行多个线程。</p><h3 id=什么时候需要协程>什么时候需要协程？</h3><p>协程切换的开销很小，且花费的内存小，在IO耗时较长的时候且任务较多的时候，协程的性能一定比线程要好。</p><h2 id=实战分析>实战分析</h2><p>来自于工作中碰到的简化场景，具体来说是单机每秒发出1k的rpc请求。下面尝试了了多种方式，把rpc请求改为读取文件的方式。</p><h3 id=io密集型任务>i/o密集型任务</h3><p>1k</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e>####asyncio thread pool</span>
0.9911940097808838
<span style=color:#75715e>####asyncio process pool]</span>
1.2635221481323242
<span style=color:#75715e>####thread pool</span>
1.2167432308197021
<span style=color:#75715e>####process pool</span>
1.5319018363952637
</code></pre></div><p>10k</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e>####asyncio thread pool</span>
5.968851804733276
<span style=color:#75715e>####asyncio process pool]</span>
6.5089499950408936
<span style=color:#75715e>####thread pool</span>
7.458053112030029
<span style=color:#75715e>####process pool</span>
6.667386054992676
</code></pre></div><h3 id=cpu密集型任务>cpu密集型任务</h3><p>1k</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e>####asyncio thread pool</span>
0.8021156787872314
<span style=color:#75715e>####asyncio process pool]</span>
0.5527217388153076
<span style=color:#75715e>####thread pool</span>
0.7702062129974365
<span style=color:#75715e>####process pool</span>
0.4566621780395508
</code></pre></div><p>10k</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e>####asyncio thread pool</span>
7.525069952011108
<span style=color:#75715e>####asyncio process pool]</span>
3.0321288108825684
<span style=color:#75715e>####thread pool</span>
7.162564277648926
<span style=color:#75715e>####process pool</span>
1.6991519927978516
</code></pre></div><p>测试代码:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> asyncio
<span style=color:#f92672>import</span> time
<span style=color:#f92672>from</span> concurrent.futures <span style=color:#f92672>import</span> ThreadPoolExecutor, ProcessPoolExecutor, wait
<span style=color:#f92672>from</span> multiprocessing <span style=color:#f92672>import</span> Pool

total <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>task</span>():
    <span style=color:#75715e># io密集型</span>
    <span style=color:#75715e># with open(&#39;/dev/urandom&#39;, &#39;rb&#39;) as f:</span>
    <span style=color:#75715e>#     return f.read(100)</span>
    <span style=color:#75715e># cpu密集型</span>
    <span style=color:#66d9ef>return</span> sum(i <span style=color:#f92672>*</span> i <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span> <span style=color:#f92672>**</span> <span style=color:#ae81ff>5</span>))

async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>async_with_thread</span>():
    executor <span style=color:#f92672>=</span> ThreadPoolExecutor()
    loop <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>get_event_loop()
    t1 <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
    tt <span style=color:#f92672>=</span> [loop<span style=color:#f92672>.</span>run_in_executor(executor, task) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(total)]
    await asyncio<span style=color:#f92672>.</span>wait(tt)
    t2 <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;####asyncio thread pool&#34;</span>)
    <span style=color:#66d9ef>print</span>(t2 <span style=color:#f92672>-</span> t1)

async <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>async_with_process</span>():
    t <span style=color:#f92672>=</span> total
    executor <span style=color:#f92672>=</span> ProcessPoolExecutor()
    loop <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>get_event_loop()
    t1 <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
    tt <span style=color:#f92672>=</span> [loop<span style=color:#f92672>.</span>run_in_executor(executor, task) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(total)]
    await asyncio<span style=color:#f92672>.</span>wait(tt)
    t2 <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;####asyncio process pool]&#34;</span>)
    <span style=color:#66d9ef>print</span>(t2 <span style=color:#f92672>-</span> t1)


<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>thread_pool</span>():
    executor <span style=color:#f92672>=</span> ThreadPoolExecutor()
    t1 <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
    futures <span style=color:#f92672>=</span> [executor<span style=color:#f92672>.</span>submit(task) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(total)]
    wait(futures)
    t2 <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;####thread pool&#34;</span>)
    <span style=color:#66d9ef>print</span>(t2 <span style=color:#f92672>-</span> t1)

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>process_pool</span>():
    p <span style=color:#f92672>=</span> Pool()
    t1 <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(total):
        p<span style=color:#f92672>.</span>apply_async(task)
    p<span style=color:#f92672>.</span>close()
    p<span style=color:#f92672>.</span>join()
    t2 <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;####process pool&#34;</span>)
    <span style=color:#66d9ef>print</span>(t2 <span style=color:#f92672>-</span> t1)

<span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
    asyncio<span style=color:#f92672>.</span>run(async_with_thread())
    asyncio<span style=color:#f92672>.</span>run(async_with_process())
    thread_pool()
    process_pool()
</code></pre></div><h2 id=参考>参考</h2><ul><li><a href=https://medium.com/contentsquare-engineering-blog/multithreading-vs-multiprocessing-in-python-ece023ad55a>Multithreading VS Multiprocessing in Python</a></li><li><a href=https://stackoverflow.com/questions/1934715/difference-between-a-coroutine-and-a-thread/34823421#34823421>Difference between a &ldquo;coroutine&rdquo; and a &ldquo;thread&rdquo;?</a></li><li><a href=https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor>asyncio.loop.run_in_executor in python doc</a></li></ul></div><footer class=post-footer></footer><div class=comments><div class=comments><script src=https://utteranc.es/client.js repo=Afrankie/blog-comments issue-term=title theme=github-light crossorigin=anonymous async></script></div></div></article><div class=foot>&copy; 2021 - 2022 &#183;
<a href=/>Afrankie</a> &#183;
Theme <a href=https://github.com/RainerChiang/simpleness>Simpleness</a> Powered by <a href=https://gohugo.io/>Hugo</a> &#183;
<a href=#><i class="fas fa-chevron-up"></i></a></div></body><script src=/js/lazyload.min.js></script><script>var lazyImage=new LazyLoad({container:document.getElementById('article')})</script></html>